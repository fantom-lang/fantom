//
// Copyright (c) 2007, Brian Frank and Andy Frank
// Licensed under the Academic Free License version 3.0
//
// History:
//   30 Jun 07  Brian Frank  Creation
//
package fan.sql;

import java.sql.*;
import java.util.StringTokenizer;
import fan.sys.*;
import fan.sql.Connection;

public class ConnectionPeer
{

//////////////////////////////////////////////////////////////////////////
// Peer Factory
//////////////////////////////////////////////////////////////////////////

  public static ConnectionPeer make(Connection fan)
  {
    return new ConnectionPeer();
  }

//////////////////////////////////////////////////////////////////////////
// Lifecycle
//////////////////////////////////////////////////////////////////////////

  public static Connection open(Str database, Str username, Str password)
  {
    try
    {
      Connection self = Connection.make();
      self.peer.jconn = DriverManager.getConnection(database.val, username.val, password.val);
      self.peer.openCount = 1;
      return self;
    }
    catch (SQLException e)
    {
      throw err(e);
    }
  }

  public Boolean isClosed(Connection self)
  {
    try
    {
      return jconn.isClosed();
    }
    catch (SQLException e)
    {
      throw err(e);
    }
  }

  public Boolean close(Connection self)
  {
    try
    {
      jconn.close();
      return true;
    }
    catch (Throwable e)
    {
      e.printStackTrace();
      return false;
    }
  }

//////////////////////////////////////////////////////////////////////////
// Database metadata
//////////////////////////////////////////////////////////////////////////

  public Boolean tableExists(Connection self, Str tableName)
  {
    try
    {
      DatabaseMetaData dbData = jconn.getMetaData();
        ResultSet tables =
          dbData.getTables(null,          // catalog
                           null,          // schema pattern
                           tableName.val, // table name pattern
                           null);         // types

      boolean exists = tables.next();
      tables.close();
      return exists;
    }
    catch(SQLException ex)
    {
      throw err(ex);
    }
  }

  public List tables(Connection self)
  {
    try
    {
      DatabaseMetaData dbData = jconn.getMetaData();
      ResultSet tables =
        dbData.getTables(null,  // catalog
                         null,  // schema pattern
                         null,  // table name pattern
                         null); // types

      int nameIndex = tables.findColumn("TABLE_NAME");
      List tableList = new List(Sys.StrType, 32);
      while (tables.next())
      {
        String tableName = tables.getString(nameIndex);
        tableList.add(Str.make(tableName));
      }
      tables.close();

      return tableList.ro();
    }
    catch(SQLException ex)
    {
      throw err(ex);
    }
  }

  public Object tableRow(Connection self, Str tableName)
  {
    try
    {
      DatabaseMetaData dbData = jconn.getMetaData();
      ResultSet columns = dbData.getColumns(null, null, tableName.val, null);

      // map the meta-data to a dynamic type
      Type t = Type.makeDynamic(listOfRow);

      int nameIndex = columns.findColumn("COLUMN_NAME");
      int typeIndex = columns.findColumn("DATA_TYPE");
      int typeNameIndex = columns.findColumn("TYPE_NAME");
      int colIndex = 0;
      while (columns.next())
      {
        String name = columns.getString(nameIndex);
        String typeName = columns.getString(typeNameIndex);
        Type fanType = SqlUtil.sqlToFanType(columns.getInt(typeIndex));
        if (fanType == null)
        {
          System.out.println("WARNING: Cannot map " + typeName + " to Fan type");
          fanType = Sys.StrType;
        }
        t.add(Col.make(Int.pos(colIndex++), Str.make(name), fanType, Str.make(typeName), null));
      }

      if (colIndex == 0)
        throw SqlErr.make(Str.make("Table not found: " + tableName)).val;

      Row row = (Row)t.make();
      row.peer.cells = new Object[t.fields().sz()];;
      return row;
    }
    catch(SQLException ex)
    {
      throw err(ex);
    }
  }

  /**
   * Get the value of the last autogenerated key.
   */
  public Int lastAutoKey(Connection self)
  {
    return lastAutoGen;
  }

//////////////////////////////////////////////////////////////////////////
// Transactions
//////////////////////////////////////////////////////////////////////////

  public Boolean getAutoCommit(Connection self)
  {
    try
    {
      return jconn.getAutoCommit();
    }
    catch (SQLException e)
    {
      throw err(e);
    }
  }

  public void setAutoCommit(Connection self, Boolean b)
  {
    try
    {
      jconn.setAutoCommit(b);
    }
    catch (SQLException e)
    {
      throw err(e);
    }
  }

  public void commit(Connection self)
  {
    try
    {
      jconn.commit();
    }
    catch (SQLException e)
    {
      throw err(e);
    }
  }

  public void rollback(Connection self)
  {
    try
    {
      jconn.rollback();
    }
    catch (SQLException e)
    {
      throw err(e);
    }
  }

//////////////////////////////////////////////////////////////////////////
// Open Count
//////////////////////////////////////////////////////////////////////////

  public Int increment(Connection self)
  {
    return Int.make(++openCount);
  }

  public Int decrement(Connection self)
  {
    if (openCount != 0) openCount--;
    return Int.make(openCount);
  }

//////////////////////////////////////////////////////////////////////////
// Static Init
//////////////////////////////////////////////////////////////////////////

  static
  {
    // preload the driver classes defined in sys.props, any
    // property that starts with "sql." and ends with ".driver"
    // is assumed to be a driver class name.
    try
    {
      List envKeys = Sys.env().keys();
      int keyCount = envKeys.sz();
      for (int i = 0; i < keyCount; i++)
      {
        Str key = (Str)envKeys.get(i);
        String keyVal = key.val;
        if (!keyVal.startsWith("sql.")) continue;
        if (!keyVal.endsWith(".driver")) continue;

        String driver = ((Str)Sys.env().get(key)).val;
        try
        {
          Class.forName(driver);
        }
        catch(Exception e)
        {
          System.out.println("WARNING: Cannot preload JDBC driver: " + driver);
        }
      }
    }
    catch (Exception e)
    {
      System.out.println(e);
    }
  }

  static Type rowType;
  static List listOfRow;
  static
  {
    try
    {
      rowType = Type.find("sql::Row", true);
      listOfRow = new List(Sys.TypeType, new Type[] { rowType });
    }
    catch (Exception e)
    {
      e.printStackTrace();
    }
  }

//////////////////////////////////////////////////////////////////////////
// Utils
//////////////////////////////////////////////////////////////////////////

  static RuntimeException err(SQLException e)
  {
    return SqlErr.make(Str.make(e.getMessage()), Err.make(e)).val;
  }

//////////////////////////////////////////////////////////////////////////
// Fields
//////////////////////////////////////////////////////////////////////////

  java.sql.Connection jconn;
  Int lastAutoGen;
  int openCount;
}