**************************************************************************
** title:      Actors
** author:     Brian Frank
** created:    10 Dec 07
** copyright:  Copyright (c) 2007, Brian Frank and Andy Frank
** license:    Licensed under the Academic Free License version 3.0
**************************************************************************

Overview [#overview]
********************
Fan supports an [actor framework]`http://en.wikipedia.org/wiki/Actor_model`
for concurrency.

Fan threads are based on a [concurrency]`Concurrency` model with no
shared mutable state.

Message Passing [#messages]
***************************
TODO: working
A more sophisticated way to communicate state is via messaging.
Every thread has a message queue which may be used to send and receive
messages.  The messages themselves must be either [immutable]`Concurrency#immutability`
or [serializable]`Serialization` to ensure [thread safety]`Concurrency#sharedObjects`.

You can send an *async* message via the [Thread.sendAsync]`sys::Thread.sendAsync`
method.  An async message is placed on the thread's message queue and immediately
returns.  It is a "fire and forget" message.  If the function processing the
message returns a result or throws an exception it is ignored.

You can send a *sync* message via the [Thread.sendSync]`sys::Thread.sendSync`
method.  A sync message will block the caller until the thread processes
the message.  The result is returned to the caller, or if an exception
was raised processing the message, then that exception is raised to the
caller.

Threads which call other threads via 'sendSync' should never receive
messages themselves as this might lead to deadlocks.  Best practice is
to design service threads using strictly asynchronous messaging, and
keep synchronous messaging on client threads which don't service
requests themselves.

Coalescing Messages [#coalescing]
=================================
Often when sending messages to a thread, we can merge two messages
into a single message to save ourselves some work.  For example, it is common
in windowing systems to maintain a single union of all the dirty portions
of a window rather than of a bunch of little rectangles.  A thread can
have its messages automatically coalesced using the
[makeCoalescing]`sys::Actor.makeCoalescing` constructor.

Let's look at an example:

  class Repaint
  {
    new make(Window w, Rect d) { ... }
    Window window
    Rect dirty
  }

  toKey := |Repaint msg->Obj| { msg.window }
  coalesce := |Repaint a, Repaint b->Obj| { Repaint(a.window, a.dirty.union(b.dirty)) }
  loopCoalescing(toKey, coalesce) |Repaint msg| {...}

In this example the messages are instances of 'Repaint'.  The 'toKey' function
is used to obtain the key which determines if two messages can be coalesced.
In this example we coalesce repaints per window. If the thread detects two
pending messages with the same key (the window in this case), then it calls
the 'coalesce' function to merge the messages.  In example we return
a new 'Repaint' event with the union of the two dirty regions.

Flow Control [#flowControl]
===========================
There are various approaches to flow control, but for now Fan uses a
simple mechanism.  Every thread has a max queue size.  If an attempt
is made to post a message via either 'sendSync' or 'sendAsync' to a full
queue, then the calling thread is blocked until there is space on the
queue.  In the future we probably want a more sophisticated approach
to flow control - maybe with some deadlock detection.

Timers [#timers]
****************
The [sendLater]`sys::Actor.sendLater` method can be used to setup
a timer.  Timers post back to the message queue when they expire.
You can use 'sendLater' to setup a one-shot timer or a repeating
timer.  Example:

  x := Thread(null) |Thread t|
  {
    t.sendLater(1sec, "1sec one-shot")
    t.sendLater(3sec, "3sec one-shot")
    t.sendLater(1sec, "1sec repeating", true)
    t.loop |Obj msg| { echo(msg) }
  }
  x.start.join

The 'sendLater' method returns an object called the *ticket* which
can be pass to [cancelLater]`sys::Thread.cancelLater` method to
cancel the timer:

  ticket := sendLater(10sec, "hi")
  ...
  cancelLater(ticket)

Actor Locals [#locals]
***********************
Every actor has *actor locals* - a string/object map for storing
thread global variables.  Locals are accessed using the
[Actor.locals]`sys::Actor.locals` method.  To prevent naming
collisions, you should prefix your map keys with your pod name:

    // store a actor local
    Actor.locals["acme.global"] = "hum bug"

    // get a thread local
    Actor.locals["acme.global"]