**************************************************************************
** title:      Maps
** author:     Brian Frank
** created:    10 Apr 08
** copyright:  Copyright (c) 2007, Brian Frank and Andy Frank
** license:    Licensed under the Academic Free License version 3.0
**************************************************************************

Type Signatures [#signatures]
*****************************
  [sys::Int:sys::Str]    // formal signature for Int keys, Str values
  [Int:Str]              // unqualified type names
  Int:Str                // you can omit brackets most of the time
  Int:Str?               // Int keys, Str? values (might store null)
  [Int:Str]?             // Int:Str variable which might be null
  Str:Int[]              // Str keys, Int[] values
  [Str:Int][]            // list of Str:Int maps (need brackets)

See [docLang]`docLang::TypeSystem#mapSignature` for details.

Literals [#literals]
********************
  Int:Str[4:"four", 5:"five"]  // maps Int to Str
  [4:"four", 5:"five"]         // same as above with type inference
  [4:"four", 5f:"five"]        // Num:Str map with type inference
  Int:Str[:]                   // empty Int:Str map
  [:]                          // empty Obj:Obj map

See [docLang]`docLang::Literals#map` for details.

Access [#access]
****************
  map := [0:"zero", 1:"one", 2:"two"]
  map.size             // number of key/value pairs, returns 3
  map.isEmpty          // convenience for size == 0
  map.containsKey(2)   // returns true
  map.get(2)           // value keyed by 2, returns "two"
  map.get(9)           // returns null
  map.get(9, "nine")   // returns "nine"
  map[2]               // convenience for map.get(2), returns "two"

Modify [#modify]
****************
  map := [0:"zero", 1:"one", 2:"two"]
  map.add(3, "three")     // add 3:"three" key/value pair
  map.add(3, "Three")     // throws ArgErr since 3 is already mapped
  map.addAll([4:"four"])  // adds all the key/value pairs to map
  map.setAll([4:"Four"])  // sets or adds all the key/value pairs to map
  map.set(3, "Three")     // set value for for key 3
  map[2] = "Two"          // convenience for map.set(2, "Two")
  map[5] = "five"         // adds 5:"five" key/value pair (new key)
  map.clear               // remove all the key/value paris from the map

List Conversion [#listConversion]
*********************************
  x := [0:"zero", 1:"one", 2:"two"]
  x.keys         // list the keys, returns [0, 1, 2]
  x.values       // list the values, returns ["zero", "one", "two"]

Each (Iteration) [#each]
************************
  map := [0:"zero", 1:"one", 2:"two"]
  map.each |Str val| { echo(val) }
  map.each |Str val, Int key| { echo("$key: $val") }

  // using type inference
  map.each |val| { echo(val) }
  map.each |val, key| { echo("$key: $val") }

Map [#map]
**********
  x := [4:"four", 5:"five", 6:"six"]
  x.map(Int:Str[:]) |Str v, Int k->Obj| { return "$k=$v" }
   => [4:4=four, 5:5=five, 6:6=six]

Reduce [#reduce]
****************
  x := [4:"four", 5:"five", 6:"six"]
  x.reduce(StrBuf.make) |Obj buf, Str v->Obj| { return buf->add(v)  }
   => fourfivesix

Searching [#search]
*******************
  x := [0:"zero", 1:"one", 2:"two", 3:"three"]
  x.find |Str v->Bool| { return v[0] == 't' }        => two
  x.find |Str v->Bool| { return v[0] == 'x' }        => null
  x.findAll |Str v->Bool| { return v[0] == 't' }     => [2:two, 3:three]
  x.findAll |Str v, Int k->Bool| { return k.isEven } => [0:zero, 2:two]
  x.exclude |Str v, Int k->Bool| { return k.isEven } => [1:one, 3:three]

Case Insensitive [#caseInsensitive ]
************************************
  x := Str:Str[:] { caseInsensitive = true }
  x["a"] = "alpha"           => [a:alpha]
  x["A"]                     => alpha
  x["B"] = "beta"            => [B:beta, a:alpha]
  x.remove("b")              => [a:alpha]
  x.caseInsensitive = false  => throws UnsupportedErr: Map not empty

Readonly [#ro]
**************
  q := [0:"zero", 1:"one", 2:"two"]
  r := q.rw      // rw() on read/write always returns this (r === q)
  s := q.ro      // s is readonly map with pairs in q
  t := s.ro      // ro() on readonly always return this (t === s)
  u := s.rw      // returns read/write map with items in s (u !== s)
  s.isRO         // returns true
  s.isRW         // return false
  q.toImmutable  // resulting map isImmutable

More Info [#moreInfo]
*********************
- See [Map API]`sys::Map`: API reference for 'sys::Map'.
- See [Literals]`docLang::Literals#map`: literals and type inference rules.
- See [Signature]`docLang::TypeSystem#mapSignature`: for generic type signature.
